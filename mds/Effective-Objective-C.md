### chapter1 熟悉Objective-C
- **了解Objective-C语言的起源**
>1. 对象所占的内存总是分配在“堆空间”（heap space）
>2. 分配在堆中的内存必须直接管理,分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理.
>3. 不含*的变量可能会使用“栈空间”保存；如果改用Objective-C对象来做的话，性能会受到影响。

![](/effects/chapter1_01.jpeg)
- **在类的头文件中尽量少引入其他头文件（降低类之间的耦合**
>1. “向前声明”——将引入头文件的时机尽量延后，只在却有需要时才引入。
>2. 减少引入的头文件数量；减少编译时间。
>3. 解决相互引用的问题。（循环引用）使用#import而非#include指令虽然不会导致死循环，但会导致两个类中有一个无法被正确编译。
- **多用字面量语法，少用与之等价的方法**
```
NSNumber * number = [NSNumber numberWithInt: 1];
NSNumber * intNumber = @1;
NSNumber * floatNumber = @1.3;
NSArray * array = @[@"cat",@"dog",@"mouse"];
NSString * dog = array[1];
NSDictionary * dictionary = @{@"name":@"fuzongjian",@"sex":@"MAN"}
```
>1. 使用字面量语法所创建出来的对象必须属于Foundation框架才行。
>2. 使用字面量语法所创建出来的字符串、数组、字典对象都不可变，若想可变，则需复制一份。
```
NSMutableArray * mutable = [@[@1,@2,@3] mutableCopy]
```
- 多用类型常量，少用#define预处理指令
>1. 不要使用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只会在编译前据此执行查找与替换操作。
- 用枚举表示状态、选项、状态码
>1. 应该用枚举来表示状态机的状态，传递给方法的选项及状态码等值，给这些值起个易懂的名字。
>2. 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可以同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。
### chapter2 对象、消息、运行期
- 理解“属性”这一概念
>1. "属性"是Objective-C的一项特性，可以使用@property来定义对象中所封装的数据。
>2. 通过“特性”来指定存储数据所需的正确语义。
>3. 在设置属性所对应的实例变量时候，一定要遵从该属性所声明的语义。
>4. 在开发中应使用nonatomic属性，因为atomic属性会严重影响性能。

| 属性名 | 含义     |
| :------------- | :------------- |
| assign       | 设置方法只会执行针对“纯量类型”的简单赋值操作       |
| strong      | 该属性定义了一种“拥有关系”，为这个属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去       |
| weak       | “非拥有关系”，为这个属性设置新值时，设置方法既不保留新值也不会释放旧值；与assign属性类似，在属性所指的对象遭到摧毁时，属性值也会清空。      |
|   copy     | 所属关系与strong类似；然而在设置方法并不保留新值，而是将其copy       |
| unsafe_unretained   | 语义和assign相同，但是它适用于“对象类型”，该特质百表达一种“非拥有关系”，当目标对象遭到摧毁时，属性值不会自动清空，这点与weak有区别。       |
